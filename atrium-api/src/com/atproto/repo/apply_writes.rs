// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Definitions for the `com.atproto.repo.applyWrites` namespace.
pub const NSID: &str = "com.atproto.repo.applyWrites";
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct InputData {
    ///The handle or DID of the repo (aka, current account).
    pub repo: crate::types::string::AtIdentifier,
    ///If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub swap_commit: core::option::Option<crate::types::string::Cid>,
    ///Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub validate: core::option::Option<bool>,
    pub writes: Vec<InputWritesItem>,
}
pub type Input = crate::types::Object<InputData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct OutputData {
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub commit: core::option::Option<crate::com::atproto::repo::defs::CommitMeta>,
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub results: core::option::Option<Vec<OutputResultsItem>>,
}
pub type Output = crate::types::Object<OutputData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "error", content = "message")]
pub enum Error {
    ///Indicates that the 'swapCommit' parameter did not match current commit.
    InvalidSwap(Option<String>),
}
impl std::fmt::Display for Error {
    fn fmt(&self, _f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Error::InvalidSwap(msg) => {
                write!(_f, "InvalidSwap")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
        }
        Ok(())
    }
}
///Operation which creates a new record.
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct CreateData {
    pub collection: crate::types::string::Nsid,
    ///NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub rkey: core::option::Option<crate::types::string::RecordKey>,
    pub value: crate::types::Unknown,
}
pub type Create = crate::types::Object<CreateData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct CreateResultData {
    pub cid: crate::types::string::Cid,
    pub uri: String,
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub validation_status: core::option::Option<String>,
}
pub type CreateResult = crate::types::Object<CreateResultData>;
///Operation which deletes an existing record.
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct DeleteData {
    pub collection: crate::types::string::Nsid,
    pub rkey: crate::types::string::RecordKey,
}
pub type Delete = crate::types::Object<DeleteData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct DeleteResultData {}
pub type DeleteResult = crate::types::Object<DeleteResultData>;
///Operation which updates an existing record.
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct UpdateData {
    pub collection: crate::types::string::Nsid,
    pub rkey: crate::types::string::RecordKey,
    pub value: crate::types::Unknown,
}
pub type Update = crate::types::Object<UpdateData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct UpdateResultData {
    pub cid: crate::types::string::Cid,
    pub uri: String,
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub validation_status: core::option::Option<String>,
}
pub type UpdateResult = crate::types::Object<UpdateResultData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
pub enum InputWritesItem {
    #[serde(rename = "com.atproto.repo.applyWrites#create")]
    Create(Box<Create>),
    #[serde(rename = "com.atproto.repo.applyWrites#update")]
    Update(Box<Update>),
    #[serde(rename = "com.atproto.repo.applyWrites#delete")]
    Delete(Box<Delete>),
}
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
pub enum OutputResultsItem {
    #[serde(rename = "com.atproto.repo.applyWrites#createResult")]
    CreateResult(Box<CreateResult>),
    #[serde(rename = "com.atproto.repo.applyWrites#updateResult")]
    UpdateResult(Box<UpdateResult>),
    #[serde(rename = "com.atproto.repo.applyWrites#deleteResult")]
    DeleteResult(Box<DeleteResult>),
}
